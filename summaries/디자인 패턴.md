# 디자인 패턴

---

- **디자인 패턴**
    
    프로그램을 설계할 때 발생했던 문제점을 객체 간의 상호 관계 등을 이용해 해결할 수 있도록, 규약 형태로 만든 것.
    
    - **싱글톤 패턴**
        
        하나의 클래스에 하나의 인스턴스를 갖는 패턴. 데이터베이스 연결 모듈에 많이 사용. 인스턴스 생성 비용이 줄지만, 의존성이 높아짐. mongoose의 connect 함수는 싱글톤 인스턴스 반환.
        
        - 단점: TDD의 걸림돌. 테스트는 서로 독립적이며 순서에 관계가 없어야 하지만, 싱글톤 패턴은 독립적인 인스턴스를 만들기 어려움. 모듈간의 결합을 강하게 만듬.
    - **의존성 주입(Dependency Injection)**
        
        A가 B에 의존성(결합도, 의존성, 종속성, 커플링)이 있다. B의 변경사항에 대해 A 또한 변해야 한다. 
        
        아래와 같이 의존성 주입자(Dependency Injector)를 통해 메인모듈이 직접 하위 모듈의 의존성을 주는 것을 사용하는 방법이다.
        
        원칙: 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다. 또한 둘 다 추상화에 의존해야 하며, 이 때 추상화는 세부사항에 의존하지 말아야 한다.
        
        ![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%201677de5716784ed7b69a067e73a6909f/Untitled.png)
        
        - 장점: 테스팅, 마이그레이션 수월, 의존성 방향의 일관성, 모듈간의 관계의 명확성
        - 단점: 모듈들이 더 분리되어 복잡성 증가.
    - **이터레이터 패턴**
        
        이터레이터를 사용해 컬렉션에 접근하는 디자인 패턴. 순회 가능한 여러 자료구조는 이터레이터 패턴으로 작성되어 있어 순회가 가능하다.
        
    - **MVC 패턴**
        
        3가지 구성요소로 역할을 구분해, 각 구성요소에 집중 개발 가능. 
        
        장점: 가독성, 재사용성, 확장성, 테스팅 용이.
        
        단점: 애플리케이션이 복잡해질수록 모델 뷰 관계는 복잡해짐.
        
        ![Untitled](%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%201677de5716784ed7b69a067e73a6909f/Untitled%201.png)
        
        - 뷰: 사용자 인터페이스 요소. 사용자가 볼 수 있는 화면.
            
            클라이언트의 요청 경로와 사용자 정보 및 데이터를 확인. 해당 요청을 각 비즈니스 로직(사용자, 상품, 트윗, 주문, 결제 등)별 Controller에게 전달.
            
        - 컨트롤러: 1개 이상의 모델과 1개 이상의 뷰를 잇는 다리 역할. 이벤트 등의 메인 로직을 담당.
            
            View에서 받은 요청을 파싱하고, 해당 요청을 각 비즈니스 로직의 Model에게 요청/응답을 받아, 클라이언트에게 응답
            
        - 모델: 애플리케이션의 데이터 (데이터베이스, 상수, 변수)
            
            Cotroller에서 받은 요청 기반으로 DB에 요청
            
    - **MVP 패턴**
        
        컨트롤러가 프레젠터로 변경. 뷰와 프러젠터는 더 강한 결합인 일대일 관계인 것이 특징. ex. react.js
        
    - **MVVM 패턴**
        
        컨트롤러가 뷰모델로 변경. 뷰와 뷰모델은 양방향 데이터 바인딩과 커맨드가 가능하다. ex. vue.js
        
        - 커맨드: 여러가지 요소에 대한 처리를 하나의 액션으로 처리 가능
        - 데이터 바인딩: 화면에서 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치 시키는 기법. MVVM에서 뷰모델을 변경시 뷰가 변경됨.
    - 기타 패턴
        - **팩토리 패턴**
            
            객체 생성부분을 분리해 추상화한 패턴. 상속관계에 있는 두 클래스의 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 상세한 내용을 결정하는 패턴.
            
        - 전략 패턴(정책 패턴)
            
            객체의 행위를 바꾸려 할 때, 직접 수정하지 않고, 전략이라 하는 ‘캡슐화 알고리즘’을 컨텍스트 안에서 바꿔 상호 교체가 가능하게 하는 패턴
            
            [csnote/7.java at main · wnghdcjfe/csnote](https://github.com/wnghdcjfe/csnote/blob/main/ch1/7.java)
            
        - 옵저버 패턴
            
            객체의 상태 변화를 관찰하다가, 상태 변화 발생 시, 변화를 알려주는 패턴. 주로 이벤트 기반 시스템에 사용하며, MVC 패턴에도 사용한다. 프록시 객체를 사용해 구현 가능.
            
            model의 변경사항이 생겨 update 메서드로 옵저버인 view에게 알려주고 이를 기반으로 controller 가 작동.
            
        - 프록시 패턴
            
            대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채, 인터페이스 역할을 하는 패턴. 이를 이용해, 보안, 데이터 검증, 캐싱, 로깅 등에 사용 가능.
            
            프록시: 어떤 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체. 자바스크립트에서 프록시 객체는 2개의 매개변수를 갖는다.
            
            - target: 프록시할 대상
            - handler: 프록시 객체의 target 동작을 가로채 정의할 동작들이 정해진 함수
            
            프록시 서버: 서버와 클라이언트 사이 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 프로그램. ex. nginx: nodejs의 버퍼 오버플로우 취약점을 예방하기 위해 프록시 서버로 사용.
            
        - 노출모듈  패턴
            
            즉시 실행 함수를 통해 private, public같은 접근 제어자를 만드는 패턴. 자바스크립트는 접근제어자가 없기 때문에 구현하기도 함.
            
            - 즉시실행함수: 함수 정의 하자마자 호출하는 함수, 초기화 코드 라이브러리 내 전역 변수 충돌 방지 등에 사용
            - Public: 함수 내, 자식, 외부 접근 가능 / Protected: 외부 접근 X / Private: 자식 외부 접근 X