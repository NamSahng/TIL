# OS

- **프로세스 & 스레드**
    - **프로세스**
        
        실행중인 프로그램
        
        운영체제로 부터 주소공간, 파일 메모리 등을 할당 받음
        
        구체적으로 code(코드), data(선언한 변수), heap(동적으로 만들어지는 메모리, c의 malloc), stack(임시 데이터, 지역변수, 함수 호출)로 구성
        
        프로세스 생성과 동시에 프로세스의 고유한 PCB가 생성되며, PCB에는 식별번호, 프로세스 상태, CPU레지스터(PC, SP, ...), 메모리 정보 등이 저장되어 있다.
        
        한 프로세스가 다른 프로세스 자원에 접근하려면 IPC 기법을 사용해야한다. IPC 기법에는 시스템 프로토콜을 활용하는 fork, 메시지 큐, 공유메모리, 시그널, 소켓 등을 활용한다.
        
    - **쓰레드**
        
         프로세스의 실행 단위
        
        스레드는 프로세스 내에서 Stack 영역만 따로 할당 받고 Code, Data, Heap영역은 공유
        
        하나의 프로세스를 다수의 실행단위로 구분해 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소화해 수행능력을 향상하는 것을 멀티 스레딩이라 한다.
        
        스택을 스레드마다 독립적으로 할당하는 이유는, (스택은 함수 호출 시 되돌아갈 주소값이나 지역변수를 저장하기 위한) 독립적인 실행 흐름을 갖기 위한 최소 조건이기 때문이다.
        
        스레드는 종료, 생성, 컨텍스트 전환, 소비자원 등이 프로세스에 비해 더 적다.
        
- **문맥교환**
    
    CPU의 자원을 프로세스에서 프로세스, 프로세스에서 스레드, 스레드에서 프로세스로 전환하는 것. 인터럽트나 시스템콜로 문맥교환을 요청하고, OS는 사용자모드에서 커널 모드로 변경되며, 문맥교환 시 PCB에 저장상태와 새로진행해야하는 상태를 저장한다.
    
- **멀티 프로세스 &  멀티 스레드 & GIL**
    - **멀티 프로세싱**: 하나의 응용프로그램을 여러 개의 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하도록 함.
        - 장점: 하나의 자식 프로세스의 문제가 다른 자식 프로세스에 영향 X
        - 단점: 메모리 공간, CPU시간 등이 더 많이 요구됨
    - **멀티 스레딩**: 하나의 응용프로그램을 여러 스레드로 구성해 각 스레드가 하나의 작업을 처리하도록 함. 많은 운영체제는 멀티스레드를 기본으로 함.
        - 장점: 더 효율적이다.
        - 단점: 스레드간 자원을 공유하기 때문에 동기화 문제가 생길 수 있다. 하지만 동기화로 인한 병목 현상으로 성능은 저하될 수 있다. 동기화는 문제는 lock을 통해 동시 접근을 막을 수 있다.
    - **GIL**
        
        파이썬은 GIL로 인해 한 시점에 하나의 쓰레드에 의해서 만실행 될 수 있다.
        
        파이썬에서 쓰레드을 여러 개 생성한다고 해서 여러 개의 쓰레드가 동시에 실행되는 것은 아니다. 정확히 말하자면 두 개의 쓰레드가 동시해 실행되는 것처럼 보일 뿐, 특정 시점에서는 여러 개의 쓰레드 중 하나의 쓰레드만 실행된다.
        
        [https://m.blog.naver.com/alice_k106/221566619995](https://m.blog.naver.com/alice_k106/221566619995)
        
- **프로세스 동기화**
    - **임계영역**
        
        멀티스레딩의 문제점인 동일한 자원을 동시에 접근하는 작업을 실행하는 코드영역을 임계영역이라 한다. 이러한 문제를 상호배제 알고리즘이라 하며, 이를 해결하기 위해 락과 세마포어가 있다. 두 기법 모두 완벽하게 데이터 무결성이나 데드락을 보장하지 않는다.
        
    - **락 (뮤텍스)**
        
        임계영역에 접근하는 프로세스는 lock을 획득하고, 임계영역에서 빠져나올 때 lock을 방출해 동시 접근이 안되도록 하는 상호배제기법
        
    - **세마포어**
        
        현재 공유자원 접근할 수 있는 쓰레드, 프로세스 수를 나타내는 값을 두는 상호배제 기법. 진 세마포어는 락으로 볼 수 있음.
        
- **캐시 메모리**
    
    속도가 빠른 장치와 느린 장치간의 속도 차이에 의한 병목현상을 줄이기 위한 메모리. CPU가 어떤 데이터를 원하는지 예측하면 좋으며, 예측 성능에 따라 캐시의 성능이 정해진다.
    
    예측성능을 위해 적중률(hit rate)지표를 사용하며, 이는 캐시 메모리 적중 횟수 / 전체 메모리 참조 횟수이다.
    
    적중률을 높이기 위해, 시간적 지역성(한 번본 데이터는 다시 참조 가능성이 높음)/공간적 지역성(참조한 데이터 근처 데이터는 참조 가능성이 높음)/순차적 지역성(메모리에 저장된 순서대로 참조 가능성 높음) 등을 고려한다.
    
- **동기와 비동기**
    
    동기는 요청의 결과를 받을 때까지 기다린 후에 다음 요청 수행.
    
    비동기는 요청 이후 바로 다음 요청 수행. 요청이 완료되면 콜백함수로 결과를 받음.
    
- **프로세스와 메모리**
    
    프로세스마다 4GB의 독립적인 가상 메모리를 받으며, 프로세스가 현재 사용하는 메모리만 물리적 메모리(메인메모리, HDD)에 적재한다.
    
    - **단편화(Fragmentation):** 사용하지 않는 자유 메모리
        - 외부단편화: 프로세스 사이사이에 존재하는 단편화
        - 내부단편화: 하나의 프로세스내에서 할당받은 메모리보다 사용중인 메모리가 커서 생긴 단편화
    - **메모리관리 전략**
        - **압축**
            
            외부단편화의 여유 공간들을 모으기 위해 압축하는 전략
            
        - **스와핑**
            
            메인 메모리에 적재한 프로세스와 HDD(보조기억장치)에 적재한 다른 프로세스를 서로 교체하는 기법. 이를 페이지 단위로도 수행 가능.
            
        - **페이징**
            
            외부단편화의 해소를 위해, 프로세스가 사용하는 메모리공간이 연속적이지 않아도 되도록, 프로세스의 가상 메모리를 페이지 단위로 나누는 기법. 일정한 페이지 단위로 인해 내부단편화에 안좋음.
            
        - **세그멘테이션**
            
            프로세스를 서로 다른 크기의 논리적 단위로 가상메모리를 나누는 기법. 서로 다른 크기로 인해 외부단편화에 좋지않음.