# 프로그래밍 언어

- **Call by**
    - **Call by value**
        
        복사하여 처리하기 때문에 안전하고, 값이 보존
        
        복사로 인한 메모리 사용량
        
    - **Call by reference**
        
        복사를 하지 않고 직접 참조로 빠름
        
        직접 참조로 인한 기존 값에 영향
        
    - **Call by Assignment(Call by Object-Reference)**
        
        list, dict, set과 같은 mutable 객체를 인자로 넘기면, call by ref처럼 변경이 되지만, immutable한 객체 튜플, 정수, 문자열은 값이 변할 때, call by value처럼 주소도 변한다.
        
        [https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference](https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference)
        
- **상속 & 구현**
    - 상속(Extends): 자식클래스는 부모클래스로부터 상속받아 추가, 확장 가능. 재사용성, 중복성 최소화. 일반 클래스나 추상 클래스 기반으로 구현.
    - 구현(Implements): 자식 클래스에서 재정의해 구현하는 것. 인터페이스를 기반으로 구현. python example ([https://realpython.com/python-interface/](https://realpython.com/python-interface/))
- **Namespace**
    
    네임스페이스란 프로세스를 실행할 때, 시스템의 리소스를 접근을 제어할 수 있는 기능이다. 시스템의 리소스를 분리해서 실행하도록 할 수 있다.
    
    모든 프로세스에는 다음과 같은 여러 네임스페이스가 있다. cgroup, pid, user, uts, ipc, mnt, net
    
    [https://www.44bits.io/ko/keyword/linux-container#리눅스-네임스페이스linux-namespace](https://www.44bits.io/ko/keyword/linux-container#%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4linux-namespace)
    
    [https://wizardzines.com/comics/namespaces/](https://wizardzines.com/comics/namespaces/)
    
- **Cgroup(control group)**
    
    프로세스의 그룹으로 컨테이너 안의 모든 프로세스는 같은 cgroup에 있다. cgroup 내에서는 메모리와 CPU 제한이 있어, 호스트 운영체제에 의해 관리받는다. 
    
    [https://wizardzines.com/comics/cgroups/](https://wizardzines.com/comics/cgroups/)
    
- **예외 처리**
    
    프로그램이 처리되는 동안 특정한 문제가 일어났을 때 처리를 중단하고, 다른 처리를 하는 것.
    
- **Python**
    - 인터프리터 언어(인터프리터 안에 컴파일러를 내장함)로 불리우고, 동적 타이핑 언어이다.
    - **Generator**
        
        Generator는 함수가 호출될 때, 반환하는 이터레이터의 일종이다. for loop과 달리 원하는 시점에 원하는 데이터를 받을 수 있다. 그리고 컨테이너에 기반한 이터레이터와 다르게 그 때마다 필요한 값을 받아 쓰기 때문에 메모리 사용량을 줄일 수 있다. List comprehension과 유사하게 만드는 방법과, generator 함수를 만드는 방법이 있다.
        
        대신에 loop 보다 느리다는 단점 있다.
        
        - **containers**: list, set, dict, tuple, str 와 같은 것
        - **Iterables**: iterable은 iterator를 반환할 수 있는 object이다. 위 컨테이너들 보다 더 많은 것들이 iterables이다.  ex. open file, open sockets ....
        - **Iterator**:  __next__() 메소드가 있는 객체는 iterator이다. 리스트를 for loop 돌린다고 하면, 리스트는 Iterator가 되어 next 메소드로 요소들을 반환한다.
        
        [https://nvie.com/posts/iterators-vs-generators/](https://nvie.com/posts/iterators-vs-generators/)
        
    - **Decorator**
        - **First Class -**
            - 1급 시민: 1급 시민은 변수에 담고, 함수의 인자로 전달이 가능하고, 함수의 반환값으로 전달할 수 있음
            - 1급 객체: 1급 시민 조건을 충족하는 객체
            - 1급 함수: 함수를 변수에 할당하고, 매개변수로 저장하고, 함수를 반환 가능한 것
        - **Closure**
            
            1급 함수를 지원하는 언어의 네임 바인딩 기술이다. 또한, 함수의 프리변수를 클로저가 만들 때의 값과 레퍼런스를 매핑하는 역할을 한다. 즉 자신의 영역 밖에 함수나 변수 값의 레퍼런스를 복사하고, 저장해 캡처한 값을 접근할 수 있게 한다.
            
            - 프리변수란 전역변수처럼, 2중으로 중첩된 함수에서의 , 2중 함수에서 정의되진 않았지만, 1중 함수에서 저장된 변수를 말한다.
            - **레퍼런스**: id(객체), C와 달리 파이썬에는 주소라는 개념이 없다. 레퍼런스는 겹칠 수 있다.
                
                [https://dokhakdubini.tistory.com/441](https://dokhakdubini.tistory.com/441)
                
            
            ```python
            def outer_func():
                message = 'Hi' 
                def inner_func():
                    print(message) 
                return inner_func 
            my_func = outer_func()
            print(my_func.__closure__[0].cell_contents) # Hi
            ```
            
        - **Decorator**
            
            First Class 함수와 Closure의 기술로 가능한 기술로, Wrapper나 Wrapper Function을 이용해 어떤 함수들의 실행 이전이나 이후에 공통으로 선행해야하는 기능들이 실행되게 하는 것.
            
            클래스나 함수로 Decorator 설정가능
            
            ```python
            def decorator_function(original_function):
                def wrapper_function():
                    print('{} 함수가 호출되기전 입니다.'.format(original_function.__name__))
                    return original_function()
                return wrapper_function
            @decorator_function
            def display_1():
                print('display_1 함수가 실행됐습니다.')
            @decorator_function
            def display_2():
                print('display_2 함수가 실행됐습니다.')
            display_1()
            display_2()
            ```
            
            [http://schoolofweb.net/blog/posts/파이썬-데코레이터-decorator/](http://schoolofweb.net/blog/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-decorator/)
            
    - **Lambda**
        
        익명 함수로 함수의 재사용이 필요하지 않은 경우 사용.
        
    - **Self**
        
        인스턴스 자체
        
- **프로그래밍 패러다임**
    
    프로그래밍 언어를 특징을 기반으로 분류하는 방법. 프로그래밍 언어는 여러 패러다임으로 분류될 수 있다. 
    
    ex. jdk 1.8이전 Java → 객체지향 / 하스켈 → 함수형프로그래밍
    
    ![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20660d641ea1ff40628e0e71043e4f680b/Untitled.png)
    
    ref. [https://dev.to/ggorantala/functional-programming-and-programming-paradigms-in-java-323f](https://dev.to/ggorantala/functional-programming-and-programming-paradigms-in-java-323f)
    
    - **선언형 프로그래밍**: 무엇을 풀어내는가에 집중하는 패러다임. 프로그램은 함수로 이루어진 것이다는 명제가 담김
    - **명령형 프로그래밍**: 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임. 수행할 명령들을 순서대로 써 놓음.
    - **함수형 프로그래밍**
        
        순수함수들을 블록처럼 쌓아 로직을 구현하고, 고차함수를 통해 재사용성을 높인 프로그래밍 패러다임.
        
        - 순수함수: 출력이 입력에만 의존하는 함수
        - 고차함수: 함수가 함수를 값처럼 매개변수로 받거나 함수를 반환하는 함수. 해당 언어가 일급함수를 지원해야 한다.
    - **객체지향 프로그래밍**
        
        데이터와 코드(속성과 함수)를 포함하는 오브젝트들에 기반한 프로그래밍 패러다임이다. 오브젝트의 특징은 오브젝트 자체의 함수가 속성에 접근해 수정이 가능하다는 것이다. OOP 프로그램은 오브젝트 끼리 서로 상호작용하도록 설계된다.
        
        단점: 설계에 많은 시간 소요. 다른 프로그래밍 패러다임에 비해 상대적으로 느림.
        
        - 특징
            
            상속: 상속을 통해 부모클래스의 함수나 변수를 자식 클래스가 가질 수 있으며, 파이썬은 싱글/멀티레벨/하이어라키컬/멀티플 상속이 가능하다
            
            다형성: 여러 형태를 받아들일 수 있는 성질, 상황에 따라 의미를 다르게 부여할 수 있는 특성. ex. python의 +는 문자열 정수형 변수에서 모두 작동. len()은 모든 iterable의 크기 반환 등.
            
            - 오버로딩: 같은 이름을 가진 메서드를 여러 개 두는 것
            - 오버라이딩: 하위클래스에서 상속받은 메서드를 재정의 하는 것
            
            캡슐화:  객체의 속성과 행위를 하나로 묶고 구현 내용 일부는 내부에 감춰 은닉함. 파이썬은 _ 를 이용해 은닉화 가능. [https://cjw0107.tistory.com/6](https://cjw0107.tistory.com/6)
            
            추상화: 구체적 구현 내용을 상속받은 자식 클래스가 구현하도록 부모 클래스에서는 묶는 것. 파이썬에서는 abc모듈의 abstractmethod로 구현
            
        - 설계 원칙: SOLID
            
            SRP(단일 책임 원칙): 모든 클래스는 각각 하나의 책임만 가져야 함.
            
            OCP(개방 폐쇄 원칙): 코드는 쉽게 변경하지 않으면서, 확장은 쉬워야 함.
            
            LSP(리스코프 치환 원칙): 부모 객체를 자식 객체로 치환해도 동작해야 함.
            
            ISP(인터페이스 분리 원칙): 구체적인 여러 인터페이스를 만들어야 함.
            
            DIP(의존 역전 원칙): 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됨. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 함.
            
    - **절차형 프로그래밍**
        
        로직이 수행되어야 할 연속적 계산 과정으로 이루어짐. 모듈화 하기 어렵고 유지 보수성이 떨어짐. ex. 머신러닝 배치 작업.
        
- **어셈블리어**
    
    기계어와 일대일 대응이 되는 프로그래밍 저급 언어. 컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 어셈블리어도 각각 다르게 된다.
    
- **컴파일러**
    
    전체 소스를 스캔해 한번에 번역. 초기 스캔 시간이 걸리지만, 실행파일이 만들어지면 빠름. 컴파일러는 고급언어로 작성된 소스를 기계어로 번역하는 과정에서 오브젝트 코드 파일을 만들며, 실행파일에 링킹작업으로 번역과정에서의 인터프리터보다 많은 메모리를 사용. 실행전 오류 확인 가능.
    
    오류 처리, 코드 최적화 작업을 통해 어셈블리어로 변환됨.
    
- **인터프리터**
    
    프로그램 실행 시 한 번에 한 줄씩 번역하기 때문에 실행 시간이 느림. 오브젝트 코드를 생성하지 않아 번역과정에서의 메모리 효율은 좋음. 인터프리터 언어는 OS에 종속되지 않는다.
    
- **Javascript**
    - **변수선언**: ES6가 표준이다. 변수 선언은 let/const만 사용한다. var는  지양하자. 호이스팅으로 인해 선언 이전에 사용하다.
        - **호이스팅**: var, 함수선언은 제일 위로 먼저 선언된다. 이 후에는 작성 순서대로 실행된다.
            
            cf. let const는 약간 다르다. [https://velog.io/@modolee/javascript-let-const-hoisting](https://velog.io/@modolee/javascript-let-const-hoisting)
            
    - **this**: 인스턴스 자체, 함수 안에서는 전역 변수
    - **Callback 함수**
        
        다른 함수에 인자로써 이용되는 함수이며, 어떤 이벤트에 의해 호출되는 함수. 콜백함수를 너무 겹치도록 사용하면, 가독성과 디버깅이 어려움. Promise, Async/Await를 사용해 가독성을 높일 수 있다.
        
    - **Promise**
        
        비동기 처리를 간편하게 처리할 수 있도록 하는 자바스크립트의 오브젝트 
        
        new를 이용해 프로미스를 생성하고 어떻게 처리할 지 명시하는 부분은 Producer이며, 해당 처리가 완료된 후 반환된 값을 사용하는 부분은 Consumer이다.
        
        Consumer에서 비동기 처리를 요청하면 Promise의 상태는 Pending이고, 해당 처리가 잘 완료되거나 문제가 생긴 상태를 각각 fulfilled/rejected 라 한다.
        
    - **Async/Await**
        
        Promise와 같은 기능을 하나, 보다 더 간편한 방안. 비동기로 작동하고 싶은 함수 앞에 async로 비동기 함수로 만들 수 있다. Promise안에 Promise가 있는 경우, Promise를 이용해도 가독성이 안좋아질 수 있다. 이를 위해, await은 비동기 함수가 또 다른 비동기 작업이 완료 된 후에 수행해야할 때(기존의 then) 그 비동기 작업이 완료될 때까지 기다리는 역할을 한다.